import logging
import subprocess
import os
import re
from pysat.solvers import Glucose3
from pysat.examples.rc2 import RC2
from pysat.formula import CNF, WCNF
from src.utils import SymbolicBasis

logger = logging.getLogger(__name__)

class Verifier:
    def __init__(self, parser, input_vars, output_vars):
        self.parser = parser
        self.input_vars = input_vars
        self.output_vars = output_vars
        self.num_orig_vars = parser.num_vars
        self.abc_path = "./dependencies/abc/abc"
        
    def verify(self, candidates, g_vars_map):
        """
        Checks E = F(X,Y) ^ !F(X,Y') ^ (Y' <-> Psi(X,G))
        Generates a Verilog file for the circuit E and uses ABC to check SAT.
        
        Returns: (True, None) if Safe (UNSAT).
                 (False, CounterExample) if Unsafe (SAT).
        """
        logger.info("Verifying candidate functions using ABC...")
        
        verilog_filename = "verify_struct.v"
        
        # 1. Generate Verilog Circuit
        self._generate_verilog(candidates, g_vars_map, verilog_filename)
        
        # 2. Run ABC
        # We use 'iprove' or 'sat'. 'sat' is sufficient for combinatorial miters.
        # We write the pattern to a file to parse it robustly.
        abc_command = f'read_verilog {verilog_filename}; strash; sat; write_patterns cex.data'
        cmd = [self.abc_path, "-c", abc_command]
        
        try:
            result = subprocess.run(
                cmd, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE, 
                text=True, 
                check=False
            )
        except FileNotFoundError:
            logger.error(f"ABC binary not found at {self.abc_path}")
            return False, None

        output = result.stdout
        
        # 3. Check Result
        if "UNSATISFIABLE" in output:
            logger.info("Verification PASSED. No counterexample found (UNSAT).")
            return True, None
            
        elif "SATISFIABLE" in output:
            logger.info("Verification FAILED. Counterexample found (SAT).")
            
            # Parse the inputs X and G from the pattern file generated by ABC
            cex_X, cex_G = self._parse_abc_patterns("cex.data", g_vars_map)
            
            # Reconstruct Y' (The synthesized output) in Python to ensure consistency
            cex_Y_prime = self._compute_y_prime(candidates, cex_X, cex_G)
            
            return False, (cex_X, cex_G, cex_Y_prime)
            
        else:
            logger.error(f"ABC returned unexpected output:\n{output}")
            return False, None

    def _generate_verilog(self, candidates, g_vars_map, filename):
        """
        Constructs a Verilog miter using standard Verilog-1995 syntax 
        to ensure compatibility with ABC's parser.
        Separates 'wire' and 'assign' to avoid parser errors.
        """
        with open(filename, 'w') as f:
            # --- Module Verification ---
            
            # 1. Port Names List
            ports = []
            for v in self.input_vars: ports.append(f"x_{v}")
            for v in self.output_vars: ports.append(f"y_orig_{v}")
            for v, gid in g_vars_map.items(): ports.append(f"g_{v}")
            ports.append("out")
            
            f.write("module verification(\n  ")
            f.write(",\n  ".join(ports))
            f.write("\n);\n")
            
            # 2. Port Declarations (Body)
            for v in self.input_vars: f.write(f"  input x_{v};\n")
            for v in self.output_vars: f.write(f"  input y_orig_{v};\n")
            for v, gid in g_vars_map.items(): f.write(f"  input g_{v};\n")
            f.write("  output out;\n\n")
            
            # 3. Internal Logic (Synthesis candidates)
            for y in self.output_vars:
                cand = candidates[y]
                f.write(self._verilog_basis_logic(cand['A'], f"a_{y}"))
                f.write(self._verilog_basis_logic(cand['C'], f"c_{y}"))
                
                # Logic: y_syn = A | (G & ~C)
                f.write(f"  wire y_syn_{y};\n")
                f.write(f"  assign y_syn_{y} = w_a_{y} | (g_{y} & ~w_c_{y});\n")
            
            f.write("\n")
            
            # 4. Instantiation: check_orig
            f.write("  wire valid_orig;\n")
            f.write("  formula_f check_orig (\n")
            f.write("    .valid(valid_orig),\n")
            
            mappings = []
            for v in self.input_vars: mappings.append(f".v_{v}(x_{v})")
            for v in self.output_vars: mappings.append(f".v_{v}(y_orig_{v})")
            # Note: Unconnected ports (internal vars) are allowed in Verilog instantiation
            f.write("    " + ",\n    ".join(mappings) + "\n  );\n")
            
            # 5. Instantiation: check_syn
            f.write("  wire valid_syn;\n")
            f.write("  formula_f check_syn (\n")
            f.write("    .valid(valid_syn),\n")
            
            mappings_syn = []
            for v in self.input_vars: mappings_syn.append(f".v_{v}(x_{v})")
            for v in self.output_vars: mappings_syn.append(f".v_{v}(y_syn_{v})")
            f.write("    " + ",\n    ".join(mappings_syn) + "\n  );\n")
            
            f.write("\n  assign out = valid_orig & ~valid_syn;\n")
            f.write("endmodule\n\n")
            
            # --- Module formula_f ---
            
            # Port List
            all_vars = [f"v_{i}" for i in range(1, self.parser.num_vars + 1)]
            f.write("module formula_f(\n  valid,\n  ")
            f.write(",\n  ".join(all_vars))
            f.write("\n);\n")
            
            # Port Declarations
            f.write("  output valid;\n")
            for v_name in all_vars:
                f.write(f"  input {v_name};\n")
            
            # Logic
            clause_wires = []
            for idx, cl in enumerate(self.parser.clauses):
                w_name = f"cl_{idx}"
                clause_wires.append(w_name)
                
                lits_verilog = []
                for l in cl:
                    var = abs(l)
                    sign = "" if l > 0 else "~"
                    lits_verilog.append(f"{sign}v_{var}")
                
                expr = " | ".join(lits_verilog)
                f.write(f"  wire {w_name};\n")
                f.write(f"  assign {w_name} = {expr};\n")
                
            if clause_wires:
                f.write("  assign valid = " + " & ".join(clause_wires) + ";\n")
            else:
                f.write("  assign valid = 1'b1;\n")
                
            f.write("endmodule\n")

    def _verilog_basis_logic(self, basis, wire_prefix):
        """
        Converts SymbolicBasis (cubes/clauses) to Verilog assignment.
        Returns string definition of wire w_{wire_prefix}.
        Uses explicit wire declaration + assign for ABC compatibility.
        """
        lines = []
        
        # DNF Part: OR of Cubes
        dnf_parts = []
        if not basis.cubes:
            dnf_parts.append("1'b0")
        else:
            for cube in basis.cubes:
                lits = []
                for l in cube:
                    var = abs(l)
                    sign = "" if l > 0 else "~"
                    lits.append(f"{sign}x_{var}")
                dnf_parts.append("(" + " & ".join(lits) + ")")
        
        dnf_expr = " | ".join(dnf_parts)
        lines.append(f"  wire {wire_prefix}_dnf;")
        lines.append(f"  assign {wire_prefix}_dnf = {dnf_expr};")
        
        # CNF Part: AND of Clauses
        cnf_parts = []
        if not basis.clauses:
            cnf_parts.append("1'b1")
        else:
            for cl in basis.clauses:
                lits = []
                for l in cl:
                    var = abs(l)
                    sign = "" if l > 0 else "~"
                    lits.append(f"{sign}x_{var}")
                cnf_parts.append("(" + " | ".join(lits) + ")")
                
        cnf_expr = " & ".join(cnf_parts)
        lines.append(f"  wire {wire_prefix}_cnf;")
        lines.append(f"  assign {wire_prefix}_cnf = {cnf_expr};")
        
        # Combine
        lines.append(f"  wire w_{wire_prefix};")
        lines.append(f"  assign w_{wire_prefix} = {wire_prefix}_dnf & {wire_prefix}_cnf;")
        return "\n".join(lines) + "\n"

    def _parse_abc_patterns(self, pattern_file, g_vars_map):
        """
        Parses the output of ABC's 'write_patterns'.
        Format is typically one line per pattern: "010101..." 
        corresponding to PIs in order of definition.
        """
        cex_X = {}
        cex_G = {}
        
        # We need to know the order of inputs defined in Verilog
        # Order: X (1..N), Y_orig (1..M), G (1..M)
        # Note: self.input_vars is a set usually, but we cast to list in ddb.py. 
        # Ideally we use the same list order used in generation.
        # We assume self.input_vars and self.output_vars are ordered lists here.
        
        with open(pattern_file, 'r') as f:
            lines = f.readlines()
            
        if not lines:
            return {}, {}
            
        # The pattern file usually contains just the bits, e.g., "10110"
        bits = lines[0].strip()
        
        current_idx = 0
        
        # Parse X
        for v in self.input_vars:
            val = (bits[current_idx] == '1')
            cex_X[v] = val
            current_idx += 1
            
        # Skip Y_orig (we don't need the witness Y, just X and G)
        current_idx += len(self.output_vars)
        
        # Parse G
        # g_vars_map iteration order must match generation order
        for v, gid in g_vars_map.items():
            if current_idx < len(bits):
                val = (bits[current_idx] == '1')
                cex_G[v] = val # Map output_index -> bool value of G
                current_idx += 1
            else:
                cex_G[v] = False # Should not happen
                
        return cex_X, cex_G

    def _compute_y_prime(self, candidates, cex_X, cex_G):
        """
        Re-evaluates the candidate functions on the counterexample input X, G
        to find the actual erroneous output Y'.
        """
        cex_Y_prime = {}
        for y, cand in candidates.items():
            # Y' = A or (G and !C)
            a_val = cand['A'].evaluate(cex_X)
            c_val = cand['C'].evaluate(cex_X)
            g_val = cex_G.get(y, False)
            
            y_val = a_val or (g_val and not c_val)
            cex_Y_prime[y] = y_val
            
        return cex_Y_prime

class Repairer:
    def __init__(self, parser, input_vars, output_vars):
        self.parser = parser
        self.input_vars = input_vars
        self.output_vars = output_vars
        
    def localize_and_repair(self, candidates, cex_tuple):
        cex_X, cex_G, cex_Y_prime = cex_tuple
        logger.info("Starting Fault Localization (MaxSAT)...")
        
        # 1. Fault Localization (MaxSAT)
        wcnf = WCNF()
        
        # Hard: F(X, Y) where X is fixed to cex_X
        for cl in self.parser.clauses:
            new_cl = []
            satisfied = False
            for lit in cl:
                var = abs(lit)
                if var in self.input_vars:
                    val = cex_X[var]
                    if lit < 0: val = not val
                    if val: 
                        satisfied = True
                        break
                else:
                    new_cl.append(lit)
            
            if not satisfied:
                if not new_cl:
                    pass 
                else:
                    wcnf.append(new_cl)

        # Soft: y_i == cex_Y_prime[i]
        for y in self.output_vars:
            target_val = cex_Y_prime[y]
            lit = y if target_val else -y
            wcnf.append([lit], weight=1)
            
        # Solve MaxSAT
        with RC2(wcnf) as solver:
            model = solver.compute()
            if not model:
                logger.error("MaxSAT failed to find valid Y_fix.")
                return candidates
                
            y_fix_map = {abs(l): (l>0) for l in model if abs(l) in self.output_vars}
            
        # 2. Identify and Repair
        repair_count = 0
        for y in self.output_vars:
            target = y_fix_map.get(y, False)
            current = cex_Y_prime[y]
            
            if target != current:
                logger.debug(f"Repairing y_{y}: Target {target}, Current {current}")
                self._apply_repair(y, target, current, cex_X, cex_G[y], candidates[y])
                repair_count += 1
        
        logger.info(f"Repair cycle finished. Repaired {repair_count} functions.")
        return candidates

    def _apply_repair(self, y_var, target, current, cex_X, g_val, candidate):
        x_map = cex_X
        a_val = candidate['A'].evaluate(x_map)
        
        action = None
        
        if not target and current:
            # We want 0, got 1.
            if not g_val:
                action = "SHRINK_A"
            else:
                if a_val: action = "SHRINK_A"
                else: action = "EXPAND_C"
                
        elif target and not current:
            # We want 1, got 0.
            if not g_val:
                action = "EXPAND_A"
            else:
                action = "SHRINK_C"
        
        if action:
            logger.debug(f"  Action for y_{y_var}: {action}")
            if action == "SHRINK_A":
                cl = self._make_blocking_clause(cex_X)
                candidate['A'].add_clause(cl)
            elif action == "EXPAND_A":
                cube = self._make_cube(cex_X)
                candidate['A'].add_cube(cube)
            elif action == "SHRINK_C":
                cl = self._make_blocking_clause(cex_X)
                candidate['C'].add_clause(cl)
            elif action == "EXPAND_C":
                cube = self._make_cube(cex_X)
                candidate['C'].add_cube(cube)
            
    def _make_blocking_clause(self, assignment):
        cl = []
        for var, val in assignment.items():
            if val: cl.append(-var)
            else: cl.append(var)
        return cl
        
    def _make_cube(self, assignment):
        cube = []
        for var, val in assignment.items():
            if val: cube.append(var)
            else: cube.append(-var)
        return cube