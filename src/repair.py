import logging
import subprocess
import os
from pysat.examples.rc2 import RC2
from pysat.formula import WCNF

logger = logging.getLogger(__name__)

class Verifier:
    def __init__(self, parser, input_vars, output_vars):
        self.parser = parser
        # Detect implicit inputs (variables in matrix but not quantified)
        # These act as free inputs and must be declared in Verilog to avoid "undefined wire" errors
        all_vars = set(range(1, parser.num_vars + 1))
        explicit_vars = set(input_vars) | set(output_vars)
        implicit_inputs = list(all_vars - explicit_vars)
        
        if implicit_inputs:
            logger.info(f"Detected {len(implicit_inputs)} implicit input variables: {implicit_inputs}")
        
        self.input_vars = input_vars + sorted(implicit_inputs)
        self.output_vars = output_vars
        
        # Create sets for O(1) lookups
        self.input_set = set(self.input_vars)
        self.output_set = set(self.output_vars)
        
        self.num_orig_vars = parser.num_vars
        self.abc_path = "./dependencies/abc/file_generation_cex"
        
    def verify(self, candidates, g_vars_map):
        """
        Checks E = F(X,Y) ^ !F(X,Y') ^ (Y' <-> Psi(X,G))
        Generates a Verilog file for the circuit E and uses ABC to check SAT.
        
        Returns: (True, None) if Safe (UNSAT).
                 (False, CounterExample) if Unsafe (SAT).
        """
        logger.info("Verifying candidate functions using ABC...")
        
        verilog_filename = "verify_struct.v"
        cex_filename = "cex.data"
        
        # 0. Clean up stale data
        if os.path.exists(cex_filename):
            try:
                os.remove(cex_filename)
            except OSError:
                logger.warning(f"Could not remove stale {cex_filename}")

        # 1. Generate Verilog Circuit
        self._generate_verilog(candidates, g_vars_map, verilog_filename)
        
        # 2. Run ABC
        # We use 'iprove' or 'sat'. 'sat' is sufficient for combinatorial miters.
        # We write the pattern to a file to parse it robustly.
        cmd = [self.abc_path, verilog_filename, cex_filename]
        
        try:
            result = subprocess.run(
                cmd, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE, 
                text=True, 
                check=False
            )
        except FileNotFoundError:
            logger.error(f"ABC binary not found at {self.abc_path}")
            return False, None

        output = result.stdout
        
        # 3. Check Result
        if "UNSATISFIABLE" in output:
            logger.info("Verification PASSED. No counterexample found (UNSAT).")
            return True, None
            
        elif "SATISFIABLE" in output:
            logger.info("Verification FAILED. Counterexample found (SAT).")
            
            # Check if CEX file was actually created
            if not os.path.exists(cex_filename):
                logger.error("ABC reported SAT but no cex.data file was created.")
                return False, None
            
            # Parse the inputs X and G from the pattern file generated by ABC
            cex_X, cex_G = self._parse_abc_patterns(cex_filename, g_vars_map)
            
            # Reconstruct Y' (The synthesized output) in Python to ensure consistency
            cex_Y_prime = self._compute_y_prime(candidates, cex_X, cex_G)
            
            return False, (cex_X, cex_G, cex_Y_prime)
            
        else:
            logger.error(f"ABC returned unexpected output:\n{output}")
            return False, None

    def _generate_verilog(self, candidates, g_vars_map, filename):
        """
        Constructs a Verilog miter using standard Verilog-1995 syntax.
        """
        with open(filename, 'w') as f:
            # --- Module Verification ---
            
            # 1. Port Names List
            ports = []
            for v in self.input_vars: ports.append(f"x_{v}")
            for v in self.output_vars: ports.append(f"y_orig_{v}")
            for v, gid in g_vars_map.items(): ports.append(f"g_{v}")
            ports.append("out")
            
            f.write("module verification(\n  ")
            f.write(",\n  ".join(ports))
            f.write("\n);\n")
            
            # 2. Port Declarations (Body)
            for v in self.input_vars: f.write(f"  input x_{v};\n")
            for v in self.output_vars: f.write(f"  input y_orig_{v};\n")
            for v, gid in g_vars_map.items(): f.write(f"  input g_{v};\n")
            f.write("  output out;\n\n")
            
            # 3. Internal Logic (Synthesis candidates)
            for y in self.output_vars:
                cand = candidates[y]
                f.write(self._verilog_basis_logic(cand['A'], f"a_{y}"))
                f.write(self._verilog_basis_logic(cand['C'], f"c_{y}"))
                
                # Logic: y_syn = A | (G & ~C)
                f.write(f"  wire y_syn_{y};\n")
                f.write(f"  assign y_syn_{y} = w_a_{y} | (g_{y} & ~w_c_{y});\n")
            
            f.write("\n")
            
            # 4. Instantiation: check_orig
            f.write("  wire valid_orig;\n")
            f.write("  formula_f check_orig (\n")
            f.write("    .valid(valid_orig),\n")
            
            mappings = []
            for v in self.input_vars: mappings.append(f".v_{v}(x_{v})")
            for v in self.output_vars: mappings.append(f".v_{v}(y_orig_{v})")
            f.write("    " + ",\n    ".join(mappings) + "\n  );\n")
            
            # 5. Instantiation: check_syn
            f.write("  wire valid_syn;\n")
            f.write("  formula_f check_syn (\n")
            f.write("    .valid(valid_syn),\n")
            
            mappings_syn = []
            for v in self.input_vars: mappings_syn.append(f".v_{v}(x_{v})")
            for v in self.output_vars: mappings_syn.append(f".v_{v}(y_syn_{v})")
            f.write("    " + ",\n    ".join(mappings_syn) + "\n  );\n")
            
            f.write("\n  assign out = valid_orig & ~valid_syn;\n")
            f.write("endmodule\n\n")
            
            # --- Module formula_f ---
            
            # Port List
            all_vars = [f"v_{i}" for i in range(1, self.parser.num_vars + 1)]
            f.write("module formula_f(\n  valid,\n  ")
            f.write(",\n  ".join(all_vars))
            f.write("\n);\n")
            
            # Port Declarations
            f.write("  output valid;\n")
            for v_name in all_vars:
                f.write(f"  input {v_name};\n")
            
            # Logic
            clause_wires = []
            for idx, cl in enumerate(self.parser.clauses):
                w_name = f"cl_{idx}"
                clause_wires.append(w_name)
                
                lits_verilog = []
                for l in cl:
                    var = abs(l)
                    sign = "" if l > 0 else "~"
                    lits_verilog.append(f"{sign}v_{var}")
                
                expr = " | ".join(lits_verilog)
                f.write(f"  wire {w_name};\n")
                f.write(f"  assign {w_name} = {expr};\n")
                
            if clause_wires:
                # Break huge assignments into multiple lines if needed, or chain ANDs
                # ABC handles "assign x = a & b & c..." reasonably well, but let's be clean
                f.write("  assign valid = " + " & ".join(clause_wires) + ";\n")
            else:
                f.write("  assign valid = 1'b1;\n")
                
            f.write("endmodule\n")

    def _verilog_basis_logic(self, basis, wire_prefix):
        """
        Converts SymbolicBasis (cubes/clauses) to Verilog assignment.
        Removes redundant parentheses and handles line breaks.
        """
        lines = []
        
        # Helper to map var ID to wire name
        def get_wire_name(var_id):
            if var_id in self.input_set:
                return f"x_{var_id}"
            elif var_id in self.output_set:
                return f"y_syn_{var_id}"
            else:
                return f"x_{var_id}"

        # DNF Part: OR of Cubes
        dnf_parts = []
        if not basis.cubes:
            dnf_parts.append("1'b0")
        else:
            for cube in basis.cubes:
                lits = []
                for l in cube:
                    var = abs(l)
                    sign = "" if l > 0 else "~"
                    name = get_wire_name(var)
                    lits.append(f"{sign}{name}")
                # Parentheses only around the AND-term
                dnf_parts.append("(" + " & ".join(lits) + ")")
        
        lines.append(f"  wire {wire_prefix}_dnf;")
        # Join with OR
        dnf_expr = " | ".join(dnf_parts)
        lines.append(f"  assign {wire_prefix}_dnf = {dnf_expr};")
        
        # CNF Part: AND of Clauses
        cnf_parts = []
        if not basis.clauses:
            cnf_parts.append("1'b1")
        else:
            for cl in basis.clauses:
                lits = []
                for l in cl:
                    var = abs(l)
                    sign = "" if l > 0 else "~"
                    name = get_wire_name(var)
                    lits.append(f"{sign}{name}")
                # Parentheses only around the OR-term
                cnf_parts.append("(" + " | ".join(lits) + ")")
                
        lines.append(f"  wire {wire_prefix}_cnf;")
        cnf_expr = " & ".join(cnf_parts)
        lines.append(f"  assign {wire_prefix}_cnf = {cnf_expr};")
        
        # Combine
        lines.append(f"  wire w_{wire_prefix};")
        lines.append(f"  assign w_{wire_prefix} = {wire_prefix}_dnf & {wire_prefix}_cnf;")
        return "\n".join(lines) + "\n"

    def _parse_abc_patterns(self, pattern_file, g_vars_map):
        """
        Parses the output of ABC's 'write_patterns'.
        """
        cex_X = {}
        cex_G = {}
        
        with open(pattern_file, 'r') as f:
            lines = f.readlines()
            
        if not lines:
            return {}, {}
            
        bits = lines[0].strip()
        current_idx = 0
        
        # Parse X (including implicit inputs)
        for v in self.input_vars:
            if current_idx >= len(bits): break
            val = (bits[current_idx] == '1')
            cex_X[v] = val
            current_idx += 1
            
        # Skip Y_orig (we don't need the witness Y, just X and G)
        current_idx += len(self.output_vars)
        
        # Parse G
        for v, gid in g_vars_map.items():
            if current_idx < len(bits):
                val = (bits[current_idx] == '1')
                cex_G[v] = val 
                current_idx += 1
            else:
                cex_G[v] = False 
                
        return cex_X, cex_G

    def _compute_y_prime(self, candidates, cex_X, cex_G):
        """
        Re-evaluates the candidate functions on the counterexample input X, G.
        """
        cex_Y_prime = {}
        
        current_assignment = cex_X.copy()
        
        for y in self.output_vars:
            cand = candidates[y]
            
            # Evaluate using current full assignment (X + previously computed Y)
            a_val = cand['A'].evaluate(current_assignment)
            c_val = cand['C'].evaluate(current_assignment)
            g_val = cex_G.get(y, False)
            
            y_val = a_val or (g_val and not c_val)
            
            cex_Y_prime[y] = y_val
            current_assignment[y] = y_val
            
        return cex_Y_prime

class Repairer:
    def __init__(self, parser, input_vars, output_vars):
        self.parser = parser
        # We also need to handle implicit inputs in Repairer if they appear in blocking clauses
        all_vars = set(range(1, parser.num_vars + 1))
        explicit_vars = set(input_vars) | set(output_vars)
        implicit_inputs = list(all_vars - explicit_vars)
        
        self.input_vars = input_vars + sorted(implicit_inputs)
        self.output_vars = output_vars
        self.input_set = set(self.input_vars)
        self.output_set = set(self.output_vars)
        
    def localize_and_repair(self, candidates, cex_tuple):
        cex_X, cex_G, cex_Y_prime = cex_tuple
        logger.info("Starting Fault Localization (MaxSAT)...")
        
        # 1. Fault Localization (MaxSAT)
        wcnf = WCNF()
        
        # Hard: F(X, Y) where X is fixed to cex_X
        for cl in self.parser.clauses:
            new_cl = []
            satisfied = False
            for lit in cl:
                var = abs(lit)
                if var in self.input_vars:
                    # Input vars (explicit + implicit) are in cex_X
                    val = cex_X.get(var, False)
                    if lit < 0: val = not val
                    if val: 
                        satisfied = True
                        break
                else:
                    new_cl.append(lit)
            
            if not satisfied:
                if not new_cl:
                    pass 
                else:
                    wcnf.append(new_cl)

        # Soft: y_i == cex_Y_prime[i]
        for y in self.output_vars:
            target_val = cex_Y_prime[y]
            lit = y if target_val else -y
            wcnf.append([lit], weight=1)
            
        # Solve MaxSAT
        with RC2(wcnf) as solver:
            model = solver.compute()
            if not model:
                logger.error("MaxSAT failed to find valid Y_fix.")
                return candidates
                
            y_fix_map = {abs(l): (l>0) for l in model if abs(l) in self.output_vars}
            
        # 2. Identify and Repair
        repair_count = 0
        
        # CRITICAL FIX: Use y_fix_map (Correct Y) instead of cex_Y_prime (Bad Y)
        # for diagnosing and generating repairs.
        full_assignment = cex_X.copy()
        full_assignment.update(y_fix_map)
        
        # Ensure fallback if y_fix_map is partial (shouldn't be, but for safety)
        for y in self.output_vars:
            if y not in full_assignment:
                full_assignment[y] = cex_Y_prime[y]

        for y in self.output_vars:
            target = y_fix_map.get(y, False)
            current = cex_Y_prime[y]
            
            if target != current:
                logger.debug(f"Repairing y_{y}: Target {target}, Current {current}")
                self._apply_repair(y, target, current, full_assignment, cex_G[y], candidates[y])
                repair_count += 1
        
        logger.info(f"Repair cycle finished. Repaired {repair_count} functions.")
        return candidates

    def _apply_repair(self, y_var, target, current, full_assignment, g_val, candidate):
        # 1. Evaluate A using full assignment to correctly diagnose
        a_val = candidate['A'].evaluate(full_assignment)
        
        # 2. Determine allowed variables for repair (X + Y_prev)
        try:
            y_idx = self.output_vars.index(y_var)
            allowed_y = set(self.output_vars[:y_idx])
        except ValueError:
            allowed_y = set()

        def filter_vars(var_id):
            return (var_id in self.input_set) or (var_id in allowed_y)
        
        action = None
        
        if not target and current:
            # We want 0, got 1.
            if not g_val:
                action = "SHRINK_A"
            else:
                if a_val: action = "SHRINK_A"
                else: action = "EXPAND_C"
                
        elif target and not current:
            # We want 1, got 0.
            if not g_val:
                action = "EXPAND_A"
            else:
                action = "SHRINK_C"
        
        if action:
            logger.debug(f"  Action for y_{y_var}: {action}")
            if action == "SHRINK_A":
                cl = self._make_blocking_clause(full_assignment, filter_vars)
                candidate['A'].add_clause(cl)
            elif action == "EXPAND_A":
                cube = self._make_cube(full_assignment, filter_vars)
                candidate['A'].add_cube(cube)
            elif action == "SHRINK_C":
                cl = self._make_blocking_clause(full_assignment, filter_vars)
                candidate['C'].add_clause(cl)
            elif action == "EXPAND_C":
                cube = self._make_cube(full_assignment, filter_vars)
                candidate['C'].add_cube(cube)
            
    def _make_blocking_clause(self, assignment, filter_fn):
        cl = []
        for var, val in assignment.items():
            if not filter_fn(var):
                continue
            if val: cl.append(-var)
            else: cl.append(var)
        return cl
        
    def _make_cube(self, assignment, filter_fn):
        cube = []
        for var, val in assignment.items():
            if not filter_fn(var):
                continue
            if val: cube.append(var)
            else: cube.append(-var)
        return cube